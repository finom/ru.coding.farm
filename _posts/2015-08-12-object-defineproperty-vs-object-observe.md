---
layout:     post
title:      Object.defineProperty vs Object.observe
summary:    Разберемся, что лучше.
categories: javascript
---

Не так давно в Хроме появилась потрясающая возможность, описанная в черновике спецификации ECMAScript 7: функция ``Object.observe``. Она создана для оповещения обо всех изменениях в объекте (см. [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)). Эта потрясающая возможность позволит сэкономить драгоценные ресурсы процессора во фреймворках и библиотеках, использующих так называемый dirty checking (дословно "грязная проверка") для контроля изменений данных и перерисовки DOM. Такой подход используется во фреймворке Angular 1, знаменитый своими тормозами при большом количестве элементов.

{% highlight javascript %}
var obj = {
  foo: 0,
  bar: 1
};

// вот сюда попадет "отчет" об изменениях
Object.observe(obj, function(changes) {
  console.log(changes);
});

obj.baz = 2;
// [{name: 'baz', object: <obj>, type: 'add'}]

obj.foo = 'hello';
// [{name: 'foo', object: <obj>, type: 'update', oldValue: 0}]

delete obj.baz;
// [{name: 'baz', object: <obj>, type: 'delete', oldValue: 2}]
{% endhighlight %}

Все изменения через небольшой промежуток времени (несколько миллисекунд) попадут в качестве аргумента переданной функции. Хочется сказать "WOW"!

К моему удивлению, многие забывают о том, что зарегистрировать изменения в объекте можно было и раньше с помощью функции ``Object.defineProperty``. Функция позволяет навешать на свойство объекта геттер, сеттер и некоторые другие служебные опции, называемые дескриптором свойства.

Вот так, например, вы создаете свойство ``key`` у объекта, которое:
- Имеет значение ``'static'``;
- Не перечисляется в цикле for..in;
- Его нельзя переписать (т. е. свойство только для чтения);
- Ему нельзя переустановить дескриптор (снова запустить ``Object.defineProperty`` с таким же ключем).

{% highlight javascript %}
Object.defineProperty(obj, 'key', {
  enumerable: false,
  configurable: false,
  writable: false,
  value: 'static'
});
{% endhighlight %}

С геттерами и сеттерами (одним словом их называют акцессоры или accessor, от слова access - доступ) использование функции выглядит так:

{% highlight javascript %}
Object.defineProperty(obj, 'key', {
  get: function() {
    return 42;
  },
  set: function() {
    alert("ты пытаешься установить свойство 'key'");
  }
});
{% endhighlight %}

Что тут происходит:
- При обращении к свойству ``obj.key``, вызывается функция ``get``. В данном случае, она просто возвращает число 42, но возвращаемое значение можно и просчитать (например, возвращать ``Math.random()``, тогда ``obj.key`` будет всегда "содержать" случайное значение при каждом обращении);
- При каждом присваивании свойству нового значения будет вызываться функция ``set``, в данном случае, она содержит вызов ``alert(...)``. Для контроля изменения в объекте нам нужен только сеттер.


Более подробно можете прочесть в [статье на MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).

Итак, что лучше: ``Object.defineProperty`` или ``Object.observe``?

### 1. Производительность
[Бенчмарк на jsperf](http://jsperf.com/object-observe-vs-object-defineproperty) показал невероятные результаты: скорость обычного сеттера при количестве и тераций ``1e5`` (10 тысяч) выше обзервера в 350 раз!

Но я предлагаю не сильно обращать внимание на этот тест. Из-за особенностей jsperf тест выглядит неправдоподобным по сравнению с более объективным "консольным тестом". Откройте консоль и запустите этот код:

{% highlight javascript %}
var o1 = {},
	o2 = {},
	i, j;


Object.observe( o1, function() {
	// some code which turns off browser optimization
	j++;
});

Object.defineProperty( o2, 'x', {
	set: function( v ) {
		// some code which turns off browser optimization
		j++;
	}
});


console.time( 'observe' );

for( i = j = 0; i < 1e6; i++ ) {
	o1.x = i;
}

console.timeEnd( 'observe' );


console.time( 'defineProperty' );

for( i = j = 0; i < 1e6; i++ ) {
	o2.x = i;
}

console.timeEnd( 'defineProperty' );
{% endhighlight %}
У меня получилось 1592 миллисекунд у ``Object.observe`` против 868 у ``Object.defineProperty``, т. е. первый на 80% медленнее второго. Если уменьшить количество итераций циклов до 10 тысяч, то разница будет более существенной: 32 мсек против 15 мсек.

Очко в пользу ``Object.defineProperty``. *1:0*

### 2. Своевременность регистрации изменений
Сеттер запускается сразу же, после попытки присваивания значения. Обзервер коллекционирует изменения и отдаёт их асинхронно, когда "основной цикл" разблокирован. Первый вариант, не мой взгляд, лучше: я хочу знать об изменениях сразу, чтобы запустить код, вызывающийся вследствие этих изменений (обычно событие изменения свойства). Обзервер оповестит обо всех изменениях потом.

У обоих подходов есть вои плюсы. *1:0*

### 3. Оператор ``delete``
Обзервер уведомляет так же и об удалении свойства (не только об изменении). ``Object.defineProperty``, к сожалению, такой возможности не имеет (хотя, было бы логично её добавить). К сожалению, это огромный камень в огород ``Object.defineProperty``... *1:1*

### 4. Что будем слушать?
В случае с ``Object.defineProperty`` нам нужно явно указать, какое свойство мы слушаем. Иногде это удобно и хорошо отражается на производительности. В свою очередь, ``Object.observe`` регистрирует изменения всех свойств, без исключения.

У обоих подходов есть вои плюсы. *1:1*

### 5. Поддержка браузерами
``Object.defineProperty``  поддерживается всеми браузерами, начиная с IE8. ``Object.observe`` работает только с браузерах на основе Хромиума.

Очко в пользу ``Object.defineProperty``. *2:1*

### Вывод
Несмотря на плохую поддержку браузерами, ``Object.observe`` это невероятно интересная и по-настоящему революционная возможность. Но, к сожалению, лично для меня, асинхронная задержка является самым главным аргументом против этой функции и я, как и раньше, буду пользоваться сеттерами. Надеюсь, что разработчики спецификаций решат как-нибудь проблему с ``delete``, либо браузеры, наконец, начнут  внедрять долгожданный [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy).
